<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>seriallibRTAI: seriallibRTAI.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>seriallibRTAI.c File Reference</h1>Arquivo com as funções da biblioteca seriallibRTAI. <a href="#_details">More...</a>
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;unistd.h&gt;</code><br>
<code>#include &lt;sys/io.h&gt;</code><br>
<code>#include &lt;rtai_lxrt.h&gt;</code><br>
<code>#include &lt;rtai_sem.h&gt;</code><br>
<code>#include &lt;rtai_sched.h&gt;</code><br>
<code>#include &quot;<a class="el" href="seriallibRTAI_8h.html">seriallibRTAI.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#397edf80f039860c6190cd64a4d69941">SERIALLIBRTAI_COMPORTADDRESS_1</a>&nbsp;&nbsp;&nbsp;0x3F8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#2b2f98874766f80965ecab10965b0179">SERIALLIBRTAI_COMPORTADDRESS_2</a>&nbsp;&nbsp;&nbsp;0x2F8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#f3be79c4d42c5e815785b5b6509dbd69">SERIALLIBRTAI_COMPORTADDRESS_3</a>&nbsp;&nbsp;&nbsp;0x3E8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#3ddd812fd653f749b93f01b7c256d4d5">SERIALLIBRTAI_COMPORTADDRESS_4</a>&nbsp;&nbsp;&nbsp;0x2E8</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#91ea05373fe7310203a6cd2e5517207f">seriallibRTAI_delay</a> (RTIME MaximaEsperaUS)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#360ca766caf22beee6cce6432774e76f">seriallibRTAI_init</a> (<a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a> pSerialPortConfig, int ComPortNumber, unsigned long int ComPortBPS)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#573c6c83833b3eb69c37d1cf7849e82c">seriallibRTAI_semwait</a> (<a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a> pSerialPortConfig)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#910a32de30902cc625d5c1eddfb482ab">seriallibRTAI_semsignal</a> (<a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a> pSerialPortConfig)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#493dbc5e1566c27b349eb418222ca0eb">seriallibRTAI_sendbyte</a> (<a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a> pSerialPortConfig, unsigned char *pData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#177ff296e880610fddc74c380f5812a8">seriallibRTAI_receivebyte</a> (<a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a> pSerialPortConfig, unsigned char *pData, double MaximaEsperaUS)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#28a70e3a5ac947dd238b4be1845cbbc4">seriallibRTAI_status</a> (<a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a> pSerialPortConfig)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SEM *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="seriallibRTAI_8c.html#74ad210af22afadd34ea631fd41bd860">pComPortSemaphores</a> [4]</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Arquivo com as funções da biblioteca seriallibRTAI. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="397edf80f039860c6190cd64a4d69941"></a><!-- doxytag: member="seriallibRTAI.c::SERIALLIBRTAI_COMPORTADDRESS_1" ref="397edf80f039860c6190cd64a4d69941" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIALLIBRTAI_COMPORTADDRESS_1&nbsp;&nbsp;&nbsp;0x3F8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endereço base da porta serial COM1. Uso interno. 
</div>
</div><p>
<a class="anchor" name="2b2f98874766f80965ecab10965b0179"></a><!-- doxytag: member="seriallibRTAI.c::SERIALLIBRTAI_COMPORTADDRESS_2" ref="2b2f98874766f80965ecab10965b0179" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIALLIBRTAI_COMPORTADDRESS_2&nbsp;&nbsp;&nbsp;0x2F8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endereço base da porta serial COM2. Uso interno. 
</div>
</div><p>
<a class="anchor" name="f3be79c4d42c5e815785b5b6509dbd69"></a><!-- doxytag: member="seriallibRTAI.c::SERIALLIBRTAI_COMPORTADDRESS_3" ref="f3be79c4d42c5e815785b5b6509dbd69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIALLIBRTAI_COMPORTADDRESS_3&nbsp;&nbsp;&nbsp;0x3E8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endereço base da porta serial COM3. Uso interno. 
</div>
</div><p>
<a class="anchor" name="3ddd812fd653f749b93f01b7c256d4d5"></a><!-- doxytag: member="seriallibRTAI.c::SERIALLIBRTAI_COMPORTADDRESS_4" ref="3ddd812fd653f749b93f01b7c256d4d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIALLIBRTAI_COMPORTADDRESS_4&nbsp;&nbsp;&nbsp;0x2E8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endereço base da porta serial COM4. Uso interno. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="91ea05373fe7310203a6cd2e5517207f"></a><!-- doxytag: member="seriallibRTAI.c::seriallibRTAI_delay" ref="91ea05373fe7310203a6cd2e5517207f" args="(RTIME MaximaEsperaUS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seriallibRTAI_delay           </td>
          <td>(</td>
          <td class="paramtype">RTIME&nbsp;</td>
          <td class="paramname"> <em>MaximaEsperaUS</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Função de uso interno da biblioteca, que provê um atraso em microsegundos dado por MaximaEsperaUS. Essa função bloqueia a thread. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MaximaEsperaUS</em>&nbsp;</td><td>atraso em unidade de microsegundos </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="360ca766caf22beee6cce6432774e76f"></a><!-- doxytag: member="seriallibRTAI.c::seriallibRTAI_init" ref="360ca766caf22beee6cce6432774e76f" args="(PSERIALPORTCONFIG pSerialPortConfig, int ComPortNumber, unsigned long int ComPortBPS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seriallibRTAI_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a>&nbsp;</td>
          <td class="paramname"> <em>pSerialPortConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ComPortNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long int&nbsp;</td>
          <td class="paramname"> <em>ComPortBPS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Função que inicia a porta serial ComPortNumber com a taxa dada em BPS por ComPortBPS. Essa função deverá ser chamada por cada thread que tenha acesso à porta serial ComPortNumber. Seus argumentos de chamada são: <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSerialPortConfig</em>&nbsp;</td><td>Ponteiro para estrutura SERIALPORCONFIG que guarda informações de configuração da porta serial no contexto do thread de chamada. Mesmo que uma dada porta serial seja utilizada por diversos threads, cada thread deverá ter a sua estrutura SERIALPORCONFIG. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ComPortNumber</em>&nbsp;</td><td>Numero da porta serial, no intervalo de 1 a 4. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ComPortBPS</em>&nbsp;</td><td>Taxa de comunicação em BPS, no intervalo de 2 a 115200. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SERIALLIBRTAI_SUCCESS : Porta iniciada com sucesso. <p>
SERIALLIBRTAI_ERROR_INCORRECTPORTNUMBER : Erro, corresponde a um ComPortNumber inválido. <p>
SERIALLIBRTAI_ERROR_MAXBPSPRECISION : Erro, a taxa ComPortBPS não pode ser realizada com erro inferior a. SERIALLIBRTAI_MAXBPSPRECISION. <p>
SERIALLIBRTAI_ERROR_IOPL : Erro, corresponde a uma tentativa de executar o programa sem que se tenha acesso privilegiado de administrador a portas de E/S. </dd></dl>

</div>
</div><p>
<a class="anchor" name="177ff296e880610fddc74c380f5812a8"></a><!-- doxytag: member="seriallibRTAI.c::seriallibRTAI_receivebyte" ref="177ff296e880610fddc74c380f5812a8" args="(PSERIALPORTCONFIG pSerialPortConfig, unsigned char *pData, double MaximaEsperaUS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seriallibRTAI_receivebyte           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a>&nbsp;</td>
          <td class="paramname"> <em>pSerialPortConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>MaximaEsperaUS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Função que aguarda um byte chegar pela porta serial descrita por pSerialPortConfig por um tempo máximo dado por MaximaEsperaUS, dado em microsegundos. Se um dado chegar dentro do período dado por MaximaEsperaUS, o mesmo será colocado na variável apontada por pData. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSerialPortConfig</em>&nbsp;</td><td>Ponteiro para estrutura <a class="el" href="structSERIALPORTCONFIG.html">SERIALPORTCONFIG</a> que guarda informações de configuração da porta serial no contexto do thread de chamada. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>Ponteiro para o byte recebido. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MaximaEsperaUS</em>&nbsp;</td><td>Tempo máximo de espera pela chegada de um byte pela porta. Se MaximaEsperaUS </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SERIALLIBRTAI_SUCCESS : Operação realizada com sucesso. Um byte foi recebido pela porta serial e se encontra disponível na variável apontada por pData. <p>
SERIALLIBRTAI_ERROR_MAXWAITFORRECEPTION : Nenhum bayte chegou dentro do tempo estipulado por MaximaEsperaUS </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>Essa função fica bloqueada por até MaximaEsperaUS enquanto um byte não chegar. </dd></dl>

</div>
</div><p>
<a class="anchor" name="910a32de30902cc625d5c1eddfb482ab"></a><!-- doxytag: member="seriallibRTAI.c::seriallibRTAI_semsignal" ref="910a32de30902cc625d5c1eddfb482ab" args="(PSERIALPORTCONFIG pSerialPortConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seriallibRTAI_semsignal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a>&nbsp;</td>
          <td class="paramname"> <em>pSerialPortConfig</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Função que libera semáforo que foi previamente cedido por seriallibRTAI_semwait para acessar a porta descrita por pSerialPortConfig. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSerialPortConfig</em>&nbsp;</td><td>Ponteiro para estrutura <a class="el" href="structSERIALPORTCONFIG.html">SERIALPORTCONFIG</a> que guarda informações de configuração da porta serial no contexto do thread de chamada. Mesmo que uma dada porta serial seja utilizada por diversos threads, cada thread deverá ter a sua estrutura <a class="el" href="structSERIALPORTCONFIG.html">SERIALPORTCONFIG</a>.. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>Se uma determinada porta somente é gerenciada por um só thread, não há necessidade de se usar essas funções de semáforo. As funções de semáforo têm somente utilizade em situações em que mais de um thread pode acessar a porta serial X, com X = 1, 2, 3 ou 4. <p>
Após concluir o acesso à porta serial cedido por essa função, deve-se chamar seriallibRTAI_semsignal para liberar o semáforo </dd></dl>

</div>
</div><p>
<a class="anchor" name="573c6c83833b3eb69c37d1cf7849e82c"></a><!-- doxytag: member="seriallibRTAI.c::seriallibRTAI_semwait" ref="573c6c83833b3eb69c37d1cf7849e82c" args="(PSERIALPORTCONFIG pSerialPortConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seriallibRTAI_semwait           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a>&nbsp;</td>
          <td class="paramname"> <em>pSerialPortConfig</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Função que aguarda semáforo para acessar a porta descrita por pSerialPortConfig. Juntamente com seriallibRTAI_semsignal, pode-se garantir o acesso exclusivo de um thread à porta serial. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSerialPortConfig</em>&nbsp;</td><td>Ponteiro para estrutura <a class="el" href="structSERIALPORTCONFIG.html">SERIALPORTCONFIG</a> que guarda informações de configuração da porta serial no contexto do thread de chamada. Mesmo que uma dada porta serial seja utilizada por diversos threads, cada thread deverá ter a sua estrutura <a class="el" href="structSERIALPORTCONFIG.html">SERIALPORTCONFIG</a>.. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>Se uma determinada porta somente é gerenciada por um só thread, não há necessidade de se usar essas funções de semáforo. As funções de semáforo têm somente utilizade em situações em que mais de um thread pode acessar a porta serial X, com X = 1, 2, 3 ou 4. <p>
Após concluir o acesso à porta serial cedido por essa função, deve-se chamar seriallibRTAI_semsignal para liberar o semáforo </dd></dl>

</div>
</div><p>
<a class="anchor" name="493dbc5e1566c27b349eb418222ca0eb"></a><!-- doxytag: member="seriallibRTAI.c::seriallibRTAI_sendbyte" ref="493dbc5e1566c27b349eb418222ca0eb" args="(PSERIALPORTCONFIG pSerialPortConfig, unsigned char *pData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seriallibRTAI_sendbyte           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a>&nbsp;</td>
          <td class="paramname"> <em>pSerialPortConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>pData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Função que envia um byte apontado por pData pela porta serial descrita por pSerialPortConfig. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSerialPortConfig</em>&nbsp;</td><td>Ponteiro para estrutura <a class="el" href="structSERIALPORTCONFIG.html">SERIALPORTCONFIG</a> que guarda informações de configuração da porta serial no contexto do thread de chamada. Mesmo que uma dada porta serial seja utilizada por diversos threads, cada thread deverá ter a sua estrutura <a class="el" href="structSERIALPORTCONFIG.html">SERIALPORTCONFIG</a>. Se SERIALLIBRTAI_USE_RS485 = 1, então o sinal RTS será colocado em nível lógico 1 enquanto durar o frame do byte enviado, permitindo assim ativar o driver externo de uma porta com conversor RS-485. Nessa situação, essa função somente retorna quando o byte tiver sido enviado. Caso contrário, a função somente escreverá no buffer de saída o byte apontado por pData, retornando em * seguida. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>Ponteiro para o byte que será enviado. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>SERIALLIBRTAI_SUCCESS : Dado escrito no registro de saída com sucesso. Entretanto, isso significa apenas que uma transmissão está em curso. Para se certificar de que o dado foi efetivamente transmitido, deve-se fazer uso da função <a class="el" href="seriallibRTAI_8c.html#28a70e3a5ac947dd238b4be1845cbbc4">seriallibRTAI_status()</a> <p>
SERIALLIBRTAI_ERROR_MAXWAITENDOFTRANSMISSION : Situação de erro em que a função ficou aguardando por um período de até 5 frames para disponibilização do registro de saída da porta </dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>Essa função fica bloqueada enquanto o último byte escrito no buffer de saída ainda não tiver sido enviado. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28a70e3a5ac947dd238b4be1845cbbc4"></a><!-- doxytag: member="seriallibRTAI.c::seriallibRTAI_status" ref="28a70e3a5ac947dd238b4be1845cbbc4" args="(PSERIALPORTCONFIG pSerialPortConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seriallibRTAI_status           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSERIALPORTCONFIG.html">PSERIALPORTCONFIG</a>&nbsp;</td>
          <td class="paramname"> <em>pSerialPortConfig</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Função que lê o registro de status da porta serial descrita por pSerialPortConfig. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSerialPortConfig</em>&nbsp;</td><td>Ponteiro para estrutura <a class="el" href="structSERIALPORTCONFIG.html">SERIALPORTCONFIG</a> que guarda informações de configuração da porta serial no contexto do thread de chamada. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>O valor de retorno tem os bits setados conforme que o dado foi efetivamente enviadoos eventos que ocorreram com a porta serial, que podem ser testados usando um teste lógico E bit a bit com as seguintes máscaras: <p>
SERIALLIBRTAI_STATUSMASK_ERROR_RX_FIFO <p>
SERIALLIBRTAI_STATUSMASK_EMPTY_DH_REGISTERS <p>
SERIALLIBRTAI_STATUSMASK_EMPTY_TX_REGISTER <p>
SERIALLIBRTAI_STATUSMASK_BREAK_INTERRUPT <p>
SERIALLIBRTAI_STATUSMASK_FRAMING_ERROR <p>
SERIALLIBRTAI_STATUSMASK_PARITY_ERROR <p>
SERIALLIBRTAI_STATUSMASK_OVERRUN_ERROR <p>
SERIALLIBRTAI_STATUSMASK_RX_DATA_READY <p>
As máscaras acima correspondem a eventos que são detalhados em <a href="http://www.beyondlogic.org/serial/serial.htm">http://www.beyondlogic.org/serial/serial.htm</a> </dd></dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="74ad210af22afadd34ea631fd41bd860"></a><!-- doxytag: member="seriallibRTAI.c::pComPortSemaphores" ref="74ad210af22afadd34ea631fd41bd860" args="[4]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SEM * <a class="el" href="seriallibRTAI_8c.html#74ad210af22afadd34ea631fd41bd860">pComPortSemaphores</a>[4]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vetor de ponteiros para semáforos. Cada elemento desse vetor é um ponteiro para o semáforo associado à porta X, com X = 1, 2, 3 ou 4. Os semáforos de cada porta são iniciados na chamada à função <a class="el" href="seriallibRTAI_8c.html#360ca766caf22beee6cce6432774e76f">seriallibRTAI_init()</a>. Para uso interno pelas funções <a class="el" href="seriallibRTAI_8c.html#573c6c83833b3eb69c37d1cf7849e82c">seriallibRTAI_semwait()</a> e <a class="el" href="seriallibRTAI_8c.html#910a32de30902cc625d5c1eddfb482ab">seriallibRTAI_semsignal()</a>. 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Aug 4 17:54:12 2008 for seriallibRTAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
